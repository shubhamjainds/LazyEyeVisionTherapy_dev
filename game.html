<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Falling Shapes Catcher — Lazy Eye Exercise</title>
<style>
  /* ------------------------------
     Basic page & layout
     ------------------------------ */
  :root{
    --bg:#0f1724;
    --panel: rgba(255,255,255,0.03);
    --accent: #7dd3fc;
    --glassA: #ff0000; /* defaults, will be overridden by JS */
    --glassB: #00ff00;
  }
  html,body{
    height:100%;
    margin:0;
    font-family:Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
    background: linear-gradient(180deg,#071021 0%, #081226 60%);
    color:#e6eef8;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
    overflow:hidden;
  }

  /* Game container spans full viewport */
  .game-wrap{
    position:relative;
    width:100vw;
    height:100vh;
    overflow:hidden;
    touch-action: none; /* allow touch handling */
  }

  /* Two canvases stacked precisely */
  canvas{
    position:absolute;
    left:0;
    top:0;
    width:100%;
    height:100%;
    display:block;
  }

  /* Foreground UI (score, controls, modals) */
  .ui {
    position:absolute;
    left:0;
    right:0;
    top:12px;
    pointer-events:none; /* so canvas touch events can be captured by underlying handlers */
    display:flex;
    justify-content:center;
    align-items:center;
    gap:12px;
    z-index:50;
  }
  .score-badge{
    pointer-events:auto;
    background:var(--panel);
    padding:10px 18px;
    border-radius:12px;
    box-shadow: 0 6px 20px rgba(2,6,23,0.6);
    font-size:20px;
    font-weight:700;
    color:var(--accent);
    backdrop-filter: blur(6px);
  }

  /* On-screen left / right buttons for mobile — visible and clickable */
  .controls {
    position:absolute;
    bottom:22px;
    left:0;
    right:0;
    display:flex;
    justify-content:center;
    gap:16px;
    z-index:60;
    pointer-events:none;
  }
  .control-btn{
    pointer-events:auto;
    width:64px;
    height:64px;
    border-radius:14px;
    display:flex;
    justify-content:center;
    align-items:center;
    font-size:28px;
    font-weight:700;
    background:linear-gradient(180deg, rgba(255,255,255,0.06), rgba(255,255,255,0.02));
    color:#fff;
    border: 1px solid rgba(255,255,255,0.06);
    user-select:none;
    -webkit-user-select:none;
    touch-action: manipulation;
    box-shadow: 0 6px 18px rgba(2,6,23,0.45);
  }

  /* Modal styles (welcome and game over) */
  .modal-backdrop{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(180deg, rgba(2,6,23,0.6), rgba(2,6,23,0.6));
    z-index:200;
  }
  .modal{
    width:min(540px,96%);
    background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:14px;
    padding:20px;
    box-shadow: 0 12px 40px rgba(2,6,23,0.7);
    color:#eaf6ff;
    border:1px solid rgba(255,255,255,0.04);
  }
  .modal h2{margin:0 0 10px 0; font-size:22px;}
  .modal p{margin:0 0 14px 0; opacity:0.9;}
  .inputs{display:flex; gap:10px; margin-bottom:12px;}
  .inputs input{
    flex:1;
    padding:10px 12px;
    border-radius:8px;
    border:1px solid rgba(255,255,255,0.06);
    background:rgba(0,0,0,0.28);
    color:#fff;
    font-size:16px;
  }
  .modal .actions{display:flex; gap:8px; justify-content:flex-end;}
  .btn{
    padding:10px 14px;
    border-radius:10px;
    cursor:pointer;
    border:0;
    font-weight:700;
    color:#042234;
    background:var(--accent);
    box-shadow: 0 6px 18px rgba(13,101,116,0.06);
  }
  .btn.secondary{
    background:transparent;
    color:#e6eef8;
    border:1px solid rgba(255,255,255,0.06);
  }

  /* Small footer hint */
  .hint{
    font-size:13px;
    opacity:0.85;
    margin-top:8px;
  }

  /* Make sure text overlay is crisp on mobile */
  .score-badge, .modal{ -webkit-font-smoothing:antialiased; }

  /* Responsive adjustments */
  @media (max-width:520px){
    .score-badge{ font-size:18px; padding:8px 12px; }
    .control-btn{ width:56px; height:56px; font-size:24px; }
  }
</style>
</head>
<body>
  <div class="game-wrap" id="gameWrap">
    <!-- Canvas for Eye A (left eye) — falling shapes -->
    <canvas id="canvasA"></canvas>

    <!-- Canvas for Eye B (right eye) — basket and target -->
    <canvas id="canvasB"></canvas>

    <!-- Top-center score visible to both eyes -->
    <div class="ui">
      <div class="score-badge" id="scoreBadge">Score: 0</div>
    </div>

    <!-- On-screen controls (for mobile) -->
    <div class="controls" id="controls">
      <div class="control-btn" id="leftBtn" aria-label="Move left">◀</div>
      <div class="control-btn" id="rightBtn" aria-label="Move right">▶</div>
    </div>

    <!-- Welcome modal to input hex colors -->
    <div class="modal-backdrop" id="welcomeModal" style="z-index:300;">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="welcomeTitle">
        <h2 id="welcomeTitle">Falling Shapes Catcher</h2>
        <p>Enter the hex colors for your anaglyph glasses lenses (include <code>#</code>).<br>
           Left-eye lens (Eye A) will see falling shapes. Right-eye lens (Eye B) will see the basket and the target.</p>
        <div class="inputs">
          <input id="hexA" placeholder="#ff0000" value="#ff0000" />
          <input id="hexB" placeholder="#00ff00" value="#00ff00" />
        </div>
        <div class="actions">
          <button class="btn secondary" id="demoColors">Use demo (red/green)</button>
          <button class="btn" id="startBtn">Start Game</button>
        </div>
        <p class="hint">Tip: Wear the corresponding colored lenses — left lens over left eye, right lens over right eye.</p>
      </div>
    </div>

    <!-- Game Over modal -->
    <div class="modal-backdrop" id="gameOverModal" style="display:none; z-index:350;">
      <div class="modal" role="dialog" aria-modal="true" aria-labelledby="gameOverTitle">
        <h2 id="gameOverTitle">Game Over</h2>
        <p id="finalScoreText">Your Score: 0</p>
        <div class="actions" style="justify-content:center;">
          <button class="btn" id="playAgainBtn">Play Again</button>
        </div>
      </div>
    </div>

  </div>

<script>
/*
  Falling Shapes Catcher
  - Two canvases / layers for anaglyph glasses:
    canvasA -> Eye A (left lens color) : shows falling shapes.
    canvasB -> Eye B (right lens color): shows basket and target.
  - Score overlay displayed as HTML so it's visible to both eyes.
  - No external libraries. Pure JS.
*/

/* -------------------------
   Helper utilities
   ------------------------- */
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function rand(min,max){ return Math.random()*(max-min)+min; }
function choose(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function isValidHex(h){
  if(!h) return false;
  if(h[0]!="#") return false;
  return (h.length===7 || h.length===4) && /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/.test(h);
}
/* convert shorthand #abc to #aabbcc */
function expandHex(h){
  if(h.length===4) return "#" + h[1]+h[1]+h[2]+h[2]+h[3]+h[3];
  return h;
}

/* -------------------------
   Canvas setup & sizing
   ------------------------- */
const canvasA = document.getElementById('canvasA'); // Eye A (shapes)
const canvasB = document.getElementById('canvasB'); // Eye B (basket, target)
const ctxA = canvasA.getContext('2d');
const ctxB = canvasB.getContext('2d');

function fitCanvases(){
  const dpr = window.devicePixelRatio || 1;
  const w = window.innerWidth;
  const h = window.innerHeight;
  [canvasA, canvasB].forEach(c=>{
    c.width = Math.round(w * dpr);
    c.height = Math.round(h * dpr);
    c.style.width = w + 'px';
    c.style.height = h + 'px';
  });
  ctxA.setTransform(dpr,0,0,dpr,0,0);
  ctxB.setTransform(dpr,0,0,dpr,0,0);
}
window.addEventListener('resize', fitCanvases);
fitCanvases();

/* -------------------------
   Game state & config
   ------------------------- */
let game = {
  running: false,
  startTime: 0,
  duration: 60_000, // ms
  lastSpawn: 0,
  spawnInterval: 800, // ms (decreases to add difficulty)
  baseFallSpeed: 2, // pixels per frame initial
  speedMultiplier: 1,
  shapes: [], // falling shapes (visible to Eye A)
  target: null, // target shape type visible to Eye B
  basket: null,
  score: 0,
  increaseEvery: 15_000, // every 15 seconds increase difficulty
  lastIncreaseTime: 0
};

/* Screen geometry helpers */
function getWidth(){ return window.innerWidth; }
function getHeight(){ return window.innerHeight; }

/* Shape types */
const SHAPES = ['circle','square','triangle'];

/* -------------------------
   Player/Basket
   ------------------------- */
function createBasket(){
  const width = 80; // px
  const height = 18;
  return {
    x: getWidth()/2 - width/2,
    y: getHeight() - 60,
    width,
    height,
    speed: 10 // px per keypress
  };
}

/* -------------------------
   Spawn falling shapes
   ------------------------- */
function spawnShape(){
  const size = Math.round(rand(34,56)); // large for visibility
  const x = rand(size/2, getWidth() - size/2);
  const type = choose(SHAPES);
  const speed = game.baseFallSpeed * game.speedMultiplier * rand(0.9,1.2);
  const s = {
    id: cryptoRandomId(),
    x, y: -size,
    size,
    type,
    speed,
    caught: false // mark when processed
  };
  game.shapes.push(s);
}

/* small id for shapes */
function cryptoRandomId(){
  return Math.random().toString(36).slice(2,9);
}

/* -------------------------
   Collision / catching logic
   ------------------------- */
function detectCatches(){
  const b = game.basket;
  const catchY = b.y; // top of basket area
  for(let i = game.shapes.length-1; i>=0; i--){
    const s = game.shapes[i];
    // if shape has dropped to basket level or further, check horizontal overlap
    if(s.y + s.size >= b.y){
      // simple horizontal collision: center x within basket bounds
      const centerX = s.x;
      if(centerX >= b.x && centerX <= b.x + b.width){
        // it's caught
        if(!s.caught){
          s.caught = true;
          // reward/penalty based on shape type vs target
          if(s.type === game.target){
            game.score += 1;
            // choose a new target
            pickNewTarget();
          } else {
            game.score -= 1;
            // optional: keep same target
          }
          updateScoreDisplay();
          // remove the shape
          game.shapes.splice(i,1);
          continue;
        }
      } else if (s.y > getHeight() + 100){
        // missed and off-screen, just remove
        game.shapes.splice(i,1);
        continue;
      }
    }
    // remove shapes that go far below bottom to keep memory clean
    if(s.y > getHeight() + 200){
      game.shapes.splice(i,1);
    }
  }
}

/* -------------------------
   Target selection
   ------------------------- */
function pickNewTarget(){
  game.target = choose(SHAPES);
}

/* -------------------------
   Render helpers for shapes & basket
   ------------------------- */

/* Draw a shape on a given context */
function drawShape(ctx, s, color, alpha=1){
  ctx.save();
  ctx.globalAlpha = alpha;
  ctx.fillStyle = color;
  ctx.strokeStyle = color;
  const x = s.x, y = s.y, size = s.size;
  if(s.type === 'circle'){
    ctx.beginPath();
    ctx.arc(x, y + size/2, size/2, 0, Math.PI*2);
    ctx.fill();
  } else if(s.type === 'square'){
    ctx.fillRect(x - size/2, y, size, size);
  } else if(s.type === 'triangle'){
    ctx.beginPath();
    ctx.moveTo(x, y);
    ctx.lineTo(x - size/2, y + size);
    ctx.lineTo(x + size/2, y + size);
    ctx.closePath();
    ctx.fill();
  }
  ctx.restore();
}

/* Draw the basket on Eye B canvas */
function drawBasket(ctx, basket, color, alpha=1){
  ctx.save();
  ctx.globalAlpha = alpha;
  // basket body
  const x = basket.x, y = basket.y, w = basket.width, h = basket.height;
  ctx.fillStyle = color;
  roundRect(ctx, x, y, w, h, 8, true, false);
  // basket rim
  ctx.strokeStyle = shadeColor(color, -30);
  ctx.lineWidth = 3;
  ctx.stroke();
  ctx.restore();
}

/* Draw the "target" indicator above basket on Eye B canvas */
function drawTargetIndicator(ctx, targetType, centerX, bottomY, color, alpha=1){
  ctx.save();
  ctx.globalAlpha = alpha;
  const size = 44;
  const y = bottomY - 70;
  // indicator bubble
  ctx.fillStyle = "rgba(255,255,255,0.03)";
  roundRect(ctx, centerX - 70, y - 14, 140, 54, 12, true, false);
  // shape inside
  ctx.translate(centerX, y+8);
  ctx.fillStyle = color;
  const s = { x:0, y:-size/2, size:size, type:targetType};
  drawShape(ctx, s, color, alpha);
  ctx.restore();
}

/* Rounded rectangle helper */
function roundRect(ctx, x, y, w, h, r, fill, stroke){
  if (r === undefined) r = 5;
  ctx.beginPath();
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.closePath();
  if(fill) ctx.fill();
  if(stroke) ctx.stroke();
}

/* Utility to darken/lighten a hex color (for rim) */
function shadeColor(hex, percent) {
  hex = expandHex(hex).replace("#","");
  const num = parseInt(hex,16);
  const r = (num >> 16) + percent;
  const g = (num >> 8 & 0x00FF) + percent;
  const b = (num & 0x0000FF) + percent;
  const newR = clamp(Math.round(r),0,255);
  const newG = clamp(Math.round(g),0,255);
  const newB = clamp(Math.round(b),0,255);
  return "#" + ((1<<24) + (newR<<16) + (newG<<8) + newB).toString(16).slice(1);
}

/* -------------------------
   Game loop
   ------------------------- */
let lastFrameTime = 0;
function gameLoop(ts){
  if(!game.running) return;
  if(!lastFrameTime) lastFrameTime = ts;
  const delta = ts - lastFrameTime;
  lastFrameTime = ts;

  // update timers
  const now = performance.now();

  // spawn shapes based on interval
  if(now - game.lastSpawn >= game.spawnInterval){
    spawnShape();
    game.lastSpawn = now;
  }

  // gradually increase speed every game.increaseEvery
  if(now - game.lastIncreaseTime >= game.increaseEvery){
    game.speedMultiplier *= 1.12; // slightly faster
    game.spawnInterval = Math.max(260, game.spawnInterval * 0.88); // faster spawns but with cap
    game.lastIncreaseTime = now;
  }

  // update shapes positions (only Eye A's shapes physically fall)
  for(let s of game.shapes){
    s.y += s.speed * (delta/16); // normalize to ~60fps base
  }

  // detect catches (when shapes reach basket)
  detectCatches();

  // render both layers
  renderA(); // shapes layer
  renderB(); // basket & target layer

  // check end condition
  if(now - game.startTime >= game.duration){
    endGame();
    return;
  }

  requestAnimationFrame(gameLoop);
}

/* -------------------------
   Rendering for Eye A (shapes)
   ------------------------- */
let colorA = '#ff0000';
function renderA(){
  const ctx = ctxA;
  const w = getWidth(), h = getHeight();
  ctx.clearRect(0,0,w,h);

  // render background tint for eye A (subtle)
  ctx.fillStyle = 'rgba(8,10,20,0.0)';
  ctx.fillRect(0,0,w,h);

  // draw all shapes in Eye A color with some transparency
  for(let s of game.shapes){
    drawShape(ctx, s, colorA, 0.95);
  }

  // optional: HUD hint low-right (only for Eye A)
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = '#ffffff';
  ctx.font = '14px Inter, sans-serif';
  ctx.fillText('Eye A: falling shapes', 14, h - 14);
  ctx.restore();
}

/* -------------------------
   Rendering for Eye B (basket, target)
   ------------------------- */
let colorB = '#00ff00';
function renderB(){
  const ctx = ctxB;
  const w = getWidth(), h = getHeight();
  ctx.clearRect(0,0,w,h);

  // draw basket
  drawBasket(ctx, game.basket, colorB, 0.95);

  // draw target indicator centered above basket
  const centerX = game.basket.x + game.basket.width/2;
  drawTargetIndicator(ctx, game.target, centerX, game.basket.y, colorB, 0.98);

  // optional: HUD hint
  ctx.save();
  ctx.globalAlpha = 0.06;
  ctx.fillStyle = '#ffffff';
  ctx.font = '14px Inter, sans-serif';
  ctx.fillText('Eye B: basket & target', 14, h - 14);
  ctx.restore();
}

/* -------------------------
   Score display update
   ------------------------- */
const scoreBadge = document.getElementById('scoreBadge');
function updateScoreDisplay(){
  scoreBadge.textContent = `Score: ${game.score}`;
}

/* -------------------------
   Start / End / Reset
   ------------------------- */
function startGame(){
  // initialize core state
  game.running = true;
  game.startTime = performance.now();
  game.lastSpawn = 0;
  game.spawnInterval = 800;
  game.baseFallSpeed = 2;
  game.speedMultiplier = 1;
  game.lastIncreaseTime = performance.now();
  game.shapes = [];
  game.score = 0;
  pickNewTarget();
  updateScoreDisplay();
  game.basket = createBasket();

  // reset frames
  lastFrameTime = 0;

  // hide any modals
  document.getElementById('welcomeModal').style.display = 'none';
  document.getElementById('gameOverModal').style.display = 'none';

  // start loop
  requestAnimationFrame(gameLoop);
}

function endGame(){
  game.running = false;
  // show game over modal with final score
  document.getElementById('finalScoreText').textContent = `Your Score: ${game.score}`;
  document.getElementById('gameOverModal').style.display = 'flex';
}

/* -------------------------
   Controls: keyboard & touch & on-screen buttons
   ------------------------- */
let leftDown = false;
let rightDown = false;

/* keyboard */
window.addEventListener('keydown', (e)=>{
  if(!game.running) return;
  if(e.key === 'ArrowLeft' || e.key === 'Left') {
    // move left
    game.basket.x -= game.basket.speed;
    game.basket.x = clamp(game.basket.x, 8, getWidth() - game.basket.width - 8);
  } else if(e.key === 'ArrowRight' || e.key === 'Right'){
    game.basket.x += game.basket.speed;
    game.basket.x = clamp(game.basket.x, 8, getWidth() - game.basket.width - 8);
  }
});

/* Smooth touch drag: when user touches/drap on screen, set basket x to touch x */
let touchActive = false;
window.addEventListener('touchstart', (e)=>{
  if(!game.running) return;
  touchActive = true;
  const t = e.touches[0];
  moveBasketTo(t.clientX);
});
window.addEventListener('touchmove', (e)=>{
  if(!game.running || !touchActive) return;
  const t = e.touches[0];
  moveBasketTo(t.clientX);
});
window.addEventListener('touchend', (e)=>{
  touchActive = false;
});

/* Click/tap on canvas to move basket to that horizontal position (accessibility) */
document.getElementById('gameWrap').addEventListener('pointerdown', (e)=>{
  // don't interfere with multitouch
  if(!game.running) return;
  const x = e.clientX;
  moveBasketTo(x);
});

function moveBasketTo(clientX){
  const newX = clientX - game.basket.width/2;
  game.basket.x = clamp(newX, 8, getWidth() - game.basket.width - 8);
}

/* On-screen left/right buttons (mobile) */
const leftBtn = document.getElementById('leftBtn');
const rightBtn = document.getElementById('rightBtn');
leftBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); game.basket.x -= game.basket.speed*2; game.basket.x = clamp(game.basket.x,8,getWidth()-game.basket.width-8); });
rightBtn.addEventListener('touchstart', (e)=>{ e.preventDefault(); game.basket.x += game.basket.speed*2; game.basket.x = clamp(game.basket.x,8,getWidth()-game.basket.width-8); });
leftBtn.addEventListener('mousedown', ()=>{ game.basket.x -= game.basket.speed*2; game.basket.x = clamp(game.basket.x,8,getWidth()-game.basket.width-8); });
rightBtn.addEventListener('mousedown', ()=>{ game.basket.x += game.basket.speed*2; game.basket.x = clamp(game.basket.x,8,getWidth()-game.basket.width-8); });

/* -------------------------
   UI: modal handling & color inputs
   ------------------------- */
const welcomeModal = document.getElementById('welcomeModal');
const startBtn = document.getElementById('startBtn');
const demoBtn = document.getElementById('demoColors');
const hexAInput = document.getElementById('hexA');
const hexBInput = document.getElementById('hexB');
const playAgainBtn = document.getElementById('playAgainBtn');

startBtn.addEventListener('click', ()=>{
  // validate hex inputs
  let hA = hexAInput.value.trim();
  let hB = hexBInput.value.trim();
  if(!isValidHex(hA) || !isValidHex(hB)){
    alert('Please enter valid hex colors like #ff0000 and #00ff00 (include the #).');
    return;
  }
  hA = expandHex(hA);
  hB = expandHex(hB);
  setEyeColors(hA, hB);
  startGame();
});

demoBtn.addEventListener('click', ()=>{
  hexAInput.value = '#ff0000';
  hexBInput.value = '#00ff00';
  startBtn.click();
});

playAgainBtn.addEventListener('click', ()=>{
  // reset and show welcome modal again for color choice (user can keep same)
  document.getElementById('gameOverModal').style.display = 'none';
  welcomeModal.style.display = 'flex';
});

/* Set the current eye colors and apply to CSS custom props if needed */
function setEyeColors(a,b){
  colorA = a;
  colorB = b;
  // set CSS variables if you want to use them in styles
  document.documentElement.style.setProperty('--glassA', colorA);
  document.documentElement.style.setProperty('--glassB', colorB);
  // Make sure score overlay is visible: style accent decorative
  document.documentElement.style.setProperty('--accent', '#7dd3fc');
}

/* -------------------------
   Initialize default UI & start state
   ------------------------- */
(function init(){
  // show welcome modal (already visible in DOM)
  // prepare basket & state so the user sees something before start
  game.basket = createBasket();
  pickNewTarget();
  updateScoreDisplay();
  // render initial frames so page doesn't look empty
  renderA();
  renderB();
})();

/* -------------------------
   Optional: small accessibility tweaks
   ------------------------- */
// prevent scrolling on touch to keep game stable
document.body.addEventListener('touchmove', function(ev){
  if(game.running) ev.preventDefault();
}, { passive:false });

/* -------------------------
   Extra comments:
   - To change game duration, edit game.duration (ms).
   - To change spawn/initial speed adjust game.spawnInterval / game.baseFallSpeed.
   - The visual intensity for anaglyph effect is controlled by alpha values in render functions.
   - Eye A canvas draws only falling shapes; Eye B canvas draws only basket & target — use colored glasses with left lens = Eye A color.
   ------------------------- */

</script>
</body>
</html>
